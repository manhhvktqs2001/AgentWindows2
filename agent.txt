# EDR Agents - Hướng dẫn Implementation đầy đủ

## 🎯 Mục tiêu Agent

### **Agent Windows & Linux phải làm:**
1. **Monitor hệ thống** real-time (files, processes, network, registry)
2. **Scan files** với YARA rules từ server
3. **Gửi events** về server (192.168.20.85:5000)
4. **Nhận tasks** từ server và execute
5. **Quarantine files** nguy hiểm
6. **Heartbeat** để báo trạng thái
7. **Chạy như service/daemon** ẩn trong hệ thống

## 📁 Cấu trúc Project Agents

```
edr-agents/
├── cmd/
│   ├── windows-agent/
│   │   └── main.go                    # Windows entry point
│   └── linux-agent/
│       └── main.go                    # Linux entry point
│
├── internal/
│   ├── common/                        # Code chung 2 platform
│   │   ├── config.go                  # Config management
│   │   ├── agent.go                   # Main agent logic
│   │   ├── server_client.go           # HTTP client tới server
│   │   ├── heartbeat.go               # Heartbeat mechanism
│   │   ├── yara_scanner.go            # YARA scanning
│   │   ├── event_sender.go            # Send events tới server
│   │   ├── task_handler.go            # Handle tasks từ server
│   │   └── logger.go                  # Logging system
│   │
│   ├── windows/                       # Windows-specific code
│   │   ├── file_monitor.go            # File monitoring (ReadDirectoryChangesW)
│   │   ├── process_monitor.go         # Process monitoring (WMI)
│   │   ├── registry_monitor.go        # Registry monitoring
│   │   ├── network_monitor.go         # Network monitoring
│   │   ├── service.go                 # Windows service
│   │   ├── quarantine.go              # File quarantine
│   │   └── system_info.go             # System information
│   │
│   └── linux/                        # Linux-specific code
│       ├── file_monitor.go            # File monitoring (inotify)
│       ├── process_monitor.go         # Process monitoring (/proc)
│       ├── network_monitor.go         # Network monitoring (netlink)
│       ├── daemon.go                  # Linux daemon
│       ├── quarantine.go              # File quarantine
│       └── system_info.go             # System information
│
├── configs/
│   ├── windows-agent.yaml            # Windows config
│   └── linux-agent.yaml              # Linux config
│
├── scripts/
│   ├── windows/
│   │   ├── install.ps1                # Install script
│   │   ├── uninstall.ps1              # Uninstall script
│   │   └── service.ps1                # Service management
│   └── linux/
│       ├── install.sh                 # Install script
│       ├── uninstall.sh               # Uninstall script
│       └── edr-agent.service          # Systemd service
│
├── build/
│   ├── windows/
│   │   └── build.ps1                  # Windows build
│   └── linux/
│       └── build.sh                   # Linux build
│
├── go.mod
├── go.sum
└── Makefile
```

## 🛠️ Chi tiết Implementation

### **1. 🔧 Common Components (Cả 2 platform)**

#### **A. Configuration Management**
```go
// internal/common/config.go
package common

type AgentConfig struct {
    Server  ServerConfig  `yaml:"server"`
    Agent   AgentDetails  `yaml:"agent"`
    Monitor MonitorConfig `yaml:"monitor"`
    Scanner ScannerConfig `yaml:"scanner"`
    Log     LogConfig     `yaml:"log"`
}

type ServerConfig struct {
    URL          string `yaml:"url"`           // "http://192.168.20.85:5000"
    APIKey       string `yaml:"api_key"`       // Agent authentication
    Timeout      int    `yaml:"timeout"`       // HTTP timeout seconds
    RetryCount   int    `yaml:"retry_count"`   // Retry failed requests
    TLSVerify    bool   `yaml:"tls_verify"`    // Verify TLS certificates
}

type AgentDetails struct {
    ID               string `yaml:"id"`                // Unique agent ID
    Name             string `yaml:"name"`              // Agent name
    HeartbeatInterval int   `yaml:"heartbeat_interval"` // Heartbeat seconds
    EventBatchSize   int    `yaml:"event_batch_size"`  // Events per batch
    MaxQueueSize     int    `yaml:"max_queue_size"`    // Max event queue
}

type MonitorConfig struct {
    Files     FileMonitorConfig     `yaml:"files"`
    Processes ProcessMonitorConfig  `yaml:"processes"`
    Network   NetworkMonitorConfig  `yaml:"network"`
    Registry  RegistryMonitorConfig `yaml:"registry"`  // Windows only
}

type FileMonitorConfig struct {
    Enabled       bool     `yaml:"enabled"`
    Paths         []string `yaml:"paths"`          // Paths to monitor
    Recursive     bool     `yaml:"recursive"`      // Monitor subdirectories
    ScanOnWrite   bool     `yaml:"scan_on_write"`  // YARA scan on file write
    MaxFileSize   string   `yaml:"max_file_size"`  // Max file size to scan
    ExcludeExts   []string `yaml:"exclude_exts"`   // Exclude extensions
}

type ProcessMonitorConfig struct {
    Enabled        bool     `yaml:"enabled"`
    ScanExecutable bool     `yaml:"scan_executable"` // YARA scan new processes
    MonitorCmdLine bool     `yaml:"monitor_cmdline"` // Monitor command lines
    ExcludeNames   []string `yaml:"exclude_names"`   // Exclude process names
}

type NetworkMonitorConfig struct {
    Enabled      bool     `yaml:"enabled"`
    MonitorTCP   bool     `yaml:"monitor_tcp"`
    MonitorUDP   bool     `yaml:"monitor_udp"`
    ExcludePorts []int    `yaml:"exclude_ports"`  // Exclude local ports
}

type RegistryMonitorConfig struct {
    Enabled bool     `yaml:"enabled"`           // Windows only
    Keys    []string `yaml:"keys"`              // Registry keys to monitor
}

type ScannerConfig struct {
    YaraEnabled     bool   `yaml:"yara_enabled"`
    YaraRulesPath   string `yaml:"yara_rules_path"`   // Local YARA rules cache
    MaxScanThreads  int    `yaml:"max_scan_threads"`  // Max concurrent scans
    ScanTimeout     int    `yaml:"scan_timeout"`      // Scan timeout seconds
}

type LogConfig struct {
    Level    string `yaml:"level"`     // debug, info, warn, error
    Format   string `yaml:"format"`    // json, text
    FilePath string `yaml:"file_path"` // Log file path
    MaxSize  int    `yaml:"max_size"`  // Max log file size MB
}

// Config loading functions
func LoadConfig(platform string) (*AgentConfig, error) {
    configPath := fmt.Sprintf("configs/%s-agent.yaml", platform)
    
    data, err := ioutil.ReadFile(configPath)
    if err != nil {
        return nil, err
    }
    
    var config AgentConfig
    err = yaml.Unmarshal(data, &config)
    if err != nil {
        return nil, err
    }
    
    // Set defaults
    setDefaults(&config)
    
    return &config, nil
}
```

#### **B. Priority 2 - Advanced Functions:**
1. **Process Monitoring** - Monitor process creation/termination
2. **Network Monitoring** - Monitor network connections
3. **Registry Monitoring** - Monitor registry changes (Windows)
4. **Task Execution** - Execute tasks from server
5. **File Quarantine** - Isolate malicious files
6. **Configuration Updates** - Update agent config remotely

#### **C. Priority 3 - Enhanced Features:**
1. **Behavioral Analysis** - Detect suspicious patterns
2. **Memory Scanning** - Scan process memory
3. **Performance Monitoring** - System performance metrics
4. **Log Collection** - Collect system logs
5. **Threat Intelligence** - Local threat intel lookup
6. **Auto-update** - Update agent binaries

## 📋 Implementation Checklist

### **Phase 1: Foundation (Week 1-2)**
- [ ] Project structure setup
- [ ] Configuration management
- [ ] Logger implementation  
- [ ] Server communication (HTTP client)
- [ ] Agent registration
- [ ] Basic heartbeat mechanism

### **Phase 2: Core Monitoring (Week 3-4)**
- [ ] File monitoring (Windows ReadDirectoryChangesW)
- [ ] File monitoring (Linux inotify)
- [ ] Event structure definitions
- [ ] Event batching and sending
- [ ] Basic YARA scanner integration
- [ ] File hash calculation

### **Phase 3: Service Integration (Week 5)**
- [ ] Windows service implementation
- [ ] Linux daemon implementation
- [ ] Installation scripts
- [ ] Service management scripts
- [ ] Auto-start configuration

### **Phase 4: Advanced Monitoring (Week 6-7)**
- [ ] Process monitoring (Windows WMI)
- [ ] Process monitoring (Linux /proc)
- [ ] Network monitoring implementation
- [ ] Registry monitoring (Windows)
- [ ] Event correlation and filtering

### **Phase 5: Security Features (Week 8-9)**
- [ ] YARA rule management
- [ ] File quarantine mechanism
- [ ] Task execution system
- [ ] Security hardening
- [ ] Anti-tampering protection

### **Phase 6: Testing & Deployment (Week 10)**
- [ ] Unit testing
- [ ] Integration testing
- [ ] Performance testing
- [ ] Cross-platform testing
- [ ] Production deployment

## 🔧 Build & Deployment

### **A. Build Scripts**

#### **Windows Build (build/windows/build.ps1):**
```powershell
# Build Windows Agent
param(
    [string]$Version = "1.0.0",
    [string]$OutputDir = "dist/windows"
)

Write-Host "Building EDR Agent for Windows..." -ForegroundColor Green

# Set environment variables
$env:GOOS = "windows"
$env:GOARCH = "amd64"
$env:CGO_ENABLED = "1"

# Create output directory
New-Item -ItemType Directory -Force -Path $OutputDir

# Build agent
go build -ldflags "-X main.Version=$Version -X main.BuildTime=$(Get-Date -Format 'yyyy-MM-dd_HH:mm:ss')" -o "$OutputDir/edr-agent.exe" ./cmd/windows-agent

# Copy configuration files
Copy-Item "configs/windows-agent.yaml" "$OutputDir/"
Copy-Item "scripts/windows/*.ps1" "$OutputDir/"

# Create installer package
Write-Host "Creating installer package..." -ForegroundColor Yellow
# Add installer creation logic here

Write-Host "Build completed: $OutputDir" -ForegroundColor Green
```

#### **Linux Build (build/linux/build.sh):**
```bash
#!/bin/bash
# Build Linux Agent

VERSION=${1:-"1.0.0"}
OUTPUT_DIR="dist/linux"

echo "Building EDR Agent for Linux..."

# Set environment variables
export GOOS=linux
export GOARCH=amd64
export CGO_ENABLED=1

# Create output directory
mkdir -p $OUTPUT_DIR

# Build agent
go build -ldflags "-X main.Version=$VERSION -X main.BuildTime=$(date '+%Y-%m-%d_%H:%M:%S')" -o "$OUTPUT_DIR/edr-agent" ./cmd/linux-agent

# Copy configuration files
cp configs/linux-agent.yaml $OUTPUT_DIR/
cp scripts/linux/*.sh $OUTPUT_DIR/
cp scripts/linux/edr-agent.service $OUTPUT_DIR/

# Create DEB package
echo "Creating DEB package..."
# Add DEB package creation logic here

echo "Build completed: $OUTPUT_DIR"
```

### **B. Installation Scripts**

#### **Windows Installation (scripts/windows/install.ps1):**
```powershell
# EDR Agent Windows Installer
param(
    [string]$InstallPath = "C:\Program Files\EDR-Agent",
    [string]$ServiceName = "EDR-Agent",
    [switch]$Uninstall
)

if ($Uninstall) {
    Write-Host "Uninstalling EDR Agent..." -ForegroundColor Yellow
    
    # Stop service
    Stop-Service -Name $ServiceName -ErrorAction SilentlyContinue
    
    # Remove service
    sc.exe delete $ServiceName
    
    # Remove files
    Remove-Item -Path $InstallPath -Recurse -Force -ErrorAction SilentlyContinue
    
    Write-Host "EDR Agent uninstalled successfully" -ForegroundColor Green
    exit 0
}

Write-Host "Installing EDR Agent..." -ForegroundColor Green

# Create installation directory
New-Item -ItemType Directory -Force -Path $InstallPath

# Copy files
Copy-Item "edr-agent.exe" -Destination $InstallPath
Copy-Item "windows-agent.yaml" -Destination "$InstallPath\config.yaml"

# Generate agent ID
$AgentID = [System.Guid]::NewGuid().ToString()
(Get-Content "$InstallPath\config.yaml") -replace 'id: ""', "id: `"$AgentID`"" | Set-Content "$InstallPath\config.yaml"

# Install service
$ServicePath = "$InstallPath\edr-agent.exe"
sc.exe create $ServiceName binPath= $ServicePath start= auto DisplayName= "EDR Agent Service"

# Set service description
sc.exe description $ServiceName "Endpoint Detection and Response Agent"

# Start service
Start-Service -Name $ServiceName

# Add firewall rule
New-NetFirewallRule -DisplayName "EDR Agent" -Direction Outbound -Port 5000 -Protocol TCP -Action Allow

Write-Host "EDR Agent installed and started successfully" -ForegroundColor Green
Write-Host "Agent ID: $AgentID" -ForegroundColor Cyan
```

#### **Linux Installation (scripts/linux/install.sh):**
```bash
#!/bin/bash
# EDR Agent Linux Installer

INSTALL_PATH="/opt/edr-agent"
SERVICE_NAME="edr-agent"
CONFIG_PATH="/etc/edr-agent"

if [ "$1" == "uninstall" ]; then
    echo "Uninstalling EDR Agent..."
    
    # Stop and disable service
    systemctl stop $SERVICE_NAME
    systemctl disable $SERVICE_NAME
    
    # Remove service file
    rm -f /etc/systemd/system/$SERVICE_NAME.service
    systemctl daemon-reload
    
    # Remove files
    rm -rf $INSTALL_PATH
    rm -rf $CONFIG_PATH
    
    echo "EDR Agent uninstalled successfully"
    exit 0
fi

echo "Installing EDR Agent..."

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    echo "Please run as root"
    exit 1
fi

# Create directories
mkdir -p $INSTALL_PATH
mkdir -p $CONFIG_PATH

# Copy files
cp edr-agent $INSTALL_PATH/
cp linux-agent.yaml $CONFIG_PATH/config.yaml
cp edr-agent.service /etc/systemd/system/

# Generate agent ID
AGENT_ID=$(uuidgen)
sed -i "s/id: \"\"/id: \"$AGENT_ID\"/" $CONFIG_PATH/config.yaml

# Set permissions
chmod +x $INSTALL_PATH/edr-agent
chown -R root:root $INSTALL_PATH
chown -R root:root $CONFIG_PATH

# Install and start service
systemctl daemon-reload
systemctl enable $SERVICE_NAME
systemctl start $SERVICE_NAME

# Check service status
if systemctl is-active --quiet $SERVICE_NAME; then
    echo "EDR Agent installed and started successfully"
    echo "Agent ID: $AGENT_ID"
else
    echo "Failed to start EDR Agent service"
    exit 1
fi
```

### **C. Configuration Files**

#### **Windows Agent Config (configs/windows-agent.yaml):**
```yaml
server:
  url: "http://192.168.20.85:5000"
  api_key: ""  # Will be set during registration
  timeout: 30
  retry_count: 3
  tls_verify: false

agent:
  id: ""  # Will be generated during installation
  name: ""  # Will be set to hostname
  heartbeat_interval: 30
  event_batch_size: 100
  max_queue_size: 10000

monitor:
  files:
    enabled: true
    paths:
      - "C:\\Program Files"
      - "C:\\Program Files (x86)"
      - "C:\\Windows\\System32"
      - "C:\\Windows\\SysWOW64"
      - "C:\\Users"
    recursive: true
    scan_on_write: true
    max_file_size: "100MB"
    exclude_exts:
      - ".tmp"
      - ".log"
      - ".bak"
  
  processes:
    enabled: true
    scan_executable: true
    monitor_cmdline: true
    exclude_names:
      - "explorer.exe"
      - "dwm.exe"
      - "winlogon.exe"
  
  network:
    enabled: true
    monitor_tcp: true
    monitor_udp: false
    exclude_ports:
      - 135
      - 445
      - 5985
  
  registry:
    enabled: true
    keys:
      - "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"
      - "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"
      - "HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"

scanner:
  yara_enabled: true
  yara_rules_path: "yara-rules"
  max_scan_threads: 4
  scan_timeout: 30

log:
  level: "info"
  format: "json"
  file_path: "C:\\Program Files\\EDR-Agent\\logs\\agent.log"
  max_size: 100
```

#### **Linux Agent Config (configs/linux-agent.yaml):**
```yaml
server:
  url: "http://192.168.20.85:5000"
  api_key: ""
  timeout: 30
  retry_count: 3
  tls_verify: false

agent:
  id: ""
  name: ""
  heartbeat_interval: 30
  event_batch_size: 100
  max_queue_size: 10000

monitor:
  files:
    enabled: true
    paths:
      - "/usr/bin"
      - "/usr/sbin"
      - "/bin"
      - "/sbin"
      - "/opt"
      - "/home"
    recursive: true
    scan_on_write: true
    max_file_size: "100MB"
    exclude_exts:
      - ".tmp"
      - ".log"
      - ".swp"
  
  processes:
    enabled: true
    scan_executable: true
    monitor_cmdline: true
    exclude_names:
      - "init"
      - "kthreadd"
      - "systemd"
  
  network:
    enabled: true
    monitor_tcp: true
    monitor_udp: false
    exclude_ports:
      - 22
      - 25
      - 53

scanner:
  yara_enabled: true
  yara_rules_path: "/opt/edr-agent/yara-rules"
  max_scan_threads: 4
  scan_timeout: 30

log:
  level: "info"
  format: "json"
  file_path: "/var/log/edr-agent/agent.log"
  max_size: 100
```

## 🧪 Testing Strategy

### **A. Unit Testing**
```go
// tests/unit/config_test.go
func TestConfigLoading(t *testing.T) {
    config, err := common.LoadConfig("windows")
    assert.NoError(t, err)
    assert.Equal(t, "http://192.168.20.85:5000", config.Server.URL)
}

// tests/unit/server_client_test.go  
func TestServerRegistration(t *testing.T) {
    client := common.NewServerClient(testConfig, testLogger)
    agentID, err := client.Register(testRegistration)
    assert.NoError(t, err)
    assert.NotEmpty(t, agentID)
}
```

### **B. Integration Testing**
```go
// tests/integration/agent_test.go
func TestAgentLifecycle(t *testing.T) {
    agent, err := common.NewAgent("windows")
    assert.NoError(t, err)
    
    err = agent.Start()
    assert.NoError(t, err)
    
    time.Sleep(5 * time.Second)
    
    agent.Stop()
}
```

### **C. Performance Testing**
```go
// tests/performance/file_monitor_test.go
func BenchmarkFileMonitoring(b *testing.B) {
    monitor := windows.NewWindowsFileMonitor(testConfig, testLogger, testAgent)
    monitor.Start()
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        // Create test file
        createTestFile(fmt.Sprintf("test_%d.txt", i))
    }
}
```

## 🚀 Deployment Guide

### **A. Development Environment Setup**
```bash
# Clone repository
git clone <repo-url>
cd edr-agents

# Install Go dependencies
go mod tidy

# Install platform-specific dependencies
# Windows: Install TDM-GCC or Visual Studio Build Tools
# Linux: Install build-essential

# Build for current platform
make build

# Run tests
make test
```

### **B. Production Deployment**

#### **Windows Deployment:**
1. Build agent với build script
2. Test trên development machine
3. Create installer package (MSI)
4. Deploy via Group Policy hoặc SCCM
5. Monitor agent registration trên server

#### **Linux Deployment:**
1. Build agent với build script  
2. Create DEB/RPM packages
3. Deploy via package manager
4. Configure với Ansible/Puppet nếu cần
5. Monitor agent registration trên server

### **C. Monitoring & Maintenance**
```bash
# Check agent status
systemctl status edr-agent  # Linux
sc query EDR-Agent          # Windows

# View agent logs
tail -f /var/log/edr-agent/agent.log     # Linux  
Get-Content "C:\Program Files\EDR-Agent\logs\agent.log" -Tail 50  # Windows

# Update agent configuration
# Edit config file and restart service

# Agent health check
curl http://localhost:8080/health  # If health endpoint enabled
```

## 🔒 Security Considerations

### **A. Agent Security:**
1. **Code Signing** - Sign executables để avoid antivirus false positives
2. **Certificate Pinning** - Pin server certificate  
3. **Encrypted Communication** - Use TLS for all server communication
4. **Anti-Tampering** - Protect against tampering và analysis
5. **Privilege Management** - Run with minimum required privileges

### **B. Deployment Security:**
1. **Secure Installation** - Verify installer integrity
2. **Configuration Security** - Protect config files
3. **Network Security** - Firewall rules cho agent communication
4. **Access Control** - Restrict agent management access
5. **Audit Logging** - Log all agent activities

---

**Đây là roadmap đầy đủ để implement EDR Agents cho Windows và Linux! Bắt đầu từ Phase 1 và implement từng component một cách tuần tự.**. Main Agent Logic**
```go
// internal/common/agent.go
package common

import (
    "context"
    "sync"
    "time"
)

type Agent struct {
    Config       *AgentConfig
    ServerClient *ServerClient
    Scanner      *YaraScanner
    EventSender  *EventSender
    TaskHandler  *TaskHandler
    Logger       *Logger
    
    // Platform-specific monitors
    FileMonitor    FileMonitor
    ProcessMonitor ProcessMonitor
    NetworkMonitor NetworkMonitor
    
    // Control channels
    stopChan   chan bool
    eventChan  chan Event
    taskChan   chan Task
    
    // State
    isRunning  bool
    mu         sync.RWMutex
}

type Event interface {
    GetType() string
    GetTimestamp() time.Time
    GetAgentID() string
    ToJSON() []byte
}

type Task interface {
    GetID() string
    GetType() string
    Execute() error
}

// Agent lifecycle
func NewAgent(platform string) (*Agent, error) {
    // Load configuration
    config, err := LoadConfig(platform)
    if err != nil {
        return nil, err
    }
    
    // Initialize logger
    logger := NewLogger(config.Log)
    
    // Initialize server client
    serverClient := NewServerClient(config.Server, logger)
    
    // Initialize YARA scanner
    scanner := NewYaraScanner(config.Scanner, logger)
    
    // Initialize event sender
    eventSender := NewEventSender(serverClient, config.Agent, logger)
    
    // Initialize task handler
    taskHandler := NewTaskHandler(serverClient, logger)
    
    agent := &Agent{
        Config:       config,
        ServerClient: serverClient,
        Scanner:      scanner,
        EventSender:  eventSender,
        TaskHandler:  taskHandler,
        Logger:       logger,
        stopChan:     make(chan bool),
        eventChan:    make(chan Event, config.Agent.MaxQueueSize),
        taskChan:     make(chan Task, 100),
    }
    
    return agent, nil
}

func (a *Agent) Start() error {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if a.isRunning {
        return fmt.Errorf("agent already running")
    }
    
    a.Logger.Info("Starting EDR Agent...")
    
    // Register with server
    err := a.registerWithServer()
    if err != nil {
        return fmt.Errorf("failed to register with server: %w", err)
    }
    
    // Start monitors
    if a.Config.Monitor.Files.Enabled {
        err = a.FileMonitor.Start()
        if err != nil {
            a.Logger.Error("Failed to start file monitor: %v", err)
        }
    }
    
    if a.Config.Monitor.Processes.Enabled {
        err = a.ProcessMonitor.Start()
        if err != nil {
            a.Logger.Error("Failed to start process monitor: %v", err)
        }
    }
    
    if a.Config.Monitor.Network.Enabled {
        err = a.NetworkMonitor.Start()
        if err != nil {
            a.Logger.Error("Failed to start network monitor: %v", err)
        }
    }
    
    // Start background workers
    go a.heartbeatWorker()
    go a.eventWorker()
    go a.taskWorker()
    
    a.isRunning = true
    a.Logger.Info("EDR Agent started successfully")
    
    return nil
}

func (a *Agent) Stop() {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if !a.isRunning {
        return
    }
    
    a.Logger.Info("Stopping EDR Agent...")
    
    // Signal stop to all workers
    close(a.stopChan)
    
    // Stop monitors
    a.FileMonitor.Stop()
    a.ProcessMonitor.Stop()
    a.NetworkMonitor.Stop()
    
    a.isRunning = false
    a.Logger.Info("EDR Agent stopped")
}

func (a *Agent) RegisterEvent(event Event) {
    select {
    case a.eventChan <- event:
    default:
        a.Logger.Warn("Event queue full, dropping event")
    }
}

// Background workers
func (a *Agent) heartbeatWorker() {
    ticker := time.NewTicker(time.Duration(a.Config.Agent.HeartbeatInterval) * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-a.stopChan:
            return
        case <-ticker.C:
            err := a.sendHeartbeat()
            if err != nil {
                a.Logger.Error("Failed to send heartbeat: %v", err)
            }
        }
    }
}

func (a *Agent) eventWorker() {
    events := make([]Event, 0, a.Config.Agent.EventBatchSize)
    ticker := time.NewTicker(5 * time.Second) // Send batch every 5 seconds
    defer ticker.Stop()
    
    for {
        select {
        case <-a.stopChan:
            // Send remaining events
            if len(events) > 0 {
                a.EventSender.SendBatch(events)
            }
            return
            
        case event := <-a.eventChan:
            events = append(events, event)
            
            // Send batch when full
            if len(events) >= a.Config.Agent.EventBatchSize {
                a.EventSender.SendBatch(events)
                events = events[:0] // Reset slice
            }
            
        case <-ticker.C:
            // Send batch on timer
            if len(events) > 0 {
                a.EventSender.SendBatch(events)
                events = events[:0] // Reset slice
            }
        }
    }
}

func (a *Agent) taskWorker() {
    for {
        select {
        case <-a.stopChan:
            return
        case task := <-a.taskChan:
            err := task.Execute()
            if err != nil {
                a.Logger.Error("Task execution failed: %v", err)
            }
        }
    }
}
```

#### **C. Server Communication**
```go
// internal/common/server_client.go
package common

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

type ServerClient struct {
    config     ServerConfig
    httpClient *http.Client
    logger     *Logger
    agentID    string
}

type HeartbeatData struct {
    AgentID     string                 `json:"agent_id"`
    Timestamp   time.Time              `json:"timestamp"`
    Status      string                 `json:"status"`
    SystemInfo  map[string]interface{} `json:"system_info"`
    Metrics     map[string]interface{} `json:"metrics"`
}

type AgentRegistration struct {
    Hostname     string `json:"hostname"`
    IPAddress    string `json:"ip_address"`
    OSType       string `json:"os_type"`
    OSVersion    string `json:"os_version"`
    Architecture string `json:"architecture"`
    AgentVersion string `json:"agent_version"`
}

func NewServerClient(config ServerConfig, logger *Logger) *ServerClient {
    return &ServerClient{
        config: config,
        httpClient: &http.Client{
            Timeout: time.Duration(config.Timeout) * time.Second,
        },
        logger: logger,
    }
}

func (sc *ServerClient) Register(registration AgentRegistration) (string, error) {
    url := sc.config.URL + "/api/v1/agents"
    
    data, err := json.Marshal(registration)
    if err != nil {
        return "", err
    }
    
    resp, err := sc.post(url, data)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusCreated {
        return "", fmt.Errorf("registration failed: %d", resp.StatusCode)
    }
    
    var result struct {
        AgentID string `json:"agent_id"`
    }
    
    err = json.NewDecoder(resp.Body).Decode(&result)
    if err != nil {
        return "", err
    }
    
    sc.agentID = result.AgentID
    return result.AgentID, nil
}

func (sc *ServerClient) SendHeartbeat(data HeartbeatData) error {
    url := fmt.Sprintf("%s/api/v1/agents/%s/heartbeat", sc.config.URL, sc.agentID)
    
    jsonData, err := json.Marshal(data)
    if err != nil {
        return err
    }
    
    resp, err := sc.post(url, jsonData)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("heartbeat failed: %d", resp.StatusCode)
    }
    
    return nil
}

func (sc *ServerClient) SendEvents(events []Event) error {
    url := sc.config.URL + "/api/v1/events/batch"
    
    jsonData, err := json.Marshal(events)
    if err != nil {
        return err
    }
    
    resp, err := sc.post(url, jsonData)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("send events failed: %d", resp.StatusCode)
    }
    
    return nil
}

func (sc *ServerClient) GetTasks() ([]Task, error) {
    url := fmt.Sprintf("%s/api/v1/agents/%s/tasks", sc.config.URL, sc.agentID)
    
    resp, err := sc.httpClient.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("get tasks failed: %d", resp.StatusCode)
    }
    
    var tasks []Task
    err = json.NewDecoder(resp.Body).Decode(&tasks)
    return tasks, err
}

func (sc *ServerClient) post(url string, data []byte) (*http.Response, error) {
    req, err := http.NewRequest("POST", url, bytes.NewBuffer(data))
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("X-API-Key", sc.config.APIKey)
    
    return sc.httpClient.Do(req)
}
```

### **2. 🪟 Windows-Specific Implementation**

#### **A. File Monitoring (ReadDirectoryChangesW)**
```go
// internal/windows/file_monitor.go
package windows

import (
    "golang.org/x/sys/windows"
    "unsafe"
)

type WindowsFileMonitor struct {
    config      common.FileMonitorConfig
    logger      *common.Logger
    agent       *common.Agent
    directories map[string]*DirectoryWatch
    stopChan    chan bool
}

type DirectoryWatch struct {
    handle     windows.Handle
    buffer     []byte
    overlapped *windows.Overlapped
    path       string
}

type FileEvent struct {
    AgentID   string    `json:"agent_id"`
    Timestamp time.Time `json:"timestamp"`
    EventType string    `json:"event_type"`
    FilePath  string    `json:"file_path"`
    FileName  string    `json:"file_name"`
    Action    string    `json:"action"`
    FileSize  int64     `json:"file_size"`
    Hash      string    `json:"hash"`
    Platform  string    `json:"platform"`
}

func NewWindowsFileMonitor(config common.FileMonitorConfig, logger *common.Logger, agent *common.Agent) *WindowsFileMonitor {
    return &WindowsFileMonitor{
        config:      config,
        logger:      logger,
        agent:       agent,
        directories: make(map[string]*DirectoryWatch),
        stopChan:    make(chan bool),
    }
}

func (wfm *WindowsFileMonitor) Start() error {
    wfm.logger.Info("Starting Windows file monitor...")
    
    for _, path := range wfm.config.Paths {
        err := wfm.watchDirectory(path)
        if err != nil {
            wfm.logger.Error("Failed to watch directory %s: %v", path, err)
            continue
        }
        wfm.logger.Info("Watching directory: %s", path)
    }
    
    return nil
}

func (wfm *WindowsFileMonitor) Stop() {
    wfm.logger.Info("Stopping Windows file monitor...")
    close(wfm.stopChan)
    
    for _, watch := range wfm.directories {
        windows.CloseHandle(watch.handle)
    }
}

func (wfm *WindowsFileMonitor) watchDirectory(path string) error {
    // Convert path to UTF16
    pathUTF16, err := windows.UTF16PtrFromString(path)
    if err != nil {
        return err
    }
    
    // Open directory handle
    handle, err := windows.CreateFile(
        pathUTF16,
        windows.FILE_LIST_DIRECTORY,
        windows.FILE_SHARE_READ|windows.FILE_SHARE_WRITE|windows.FILE_SHARE_DELETE,
        nil,
        windows.OPEN_EXISTING,
        windows.FILE_FLAG_BACKUP_SEMANTICS|windows.FILE_FLAG_OVERLAPPED,
        0,
    )
    if err != nil {
        return err
    }
    
    // Create directory watch
    watch := &DirectoryWatch{
        handle: handle,
        buffer: make([]byte, 64*1024), // 64KB buffer
        path:   path,
    }
    
    wfm.directories[path] = watch
    go wfm.monitorDirectory(watch)
    
    return nil
}

func (wfm *WindowsFileMonitor) monitorDirectory(watch *DirectoryWatch) {
    for {
        select {
        case <-wfm.stopChan:
            return
        default:
            var bytesReturned uint32
            err := windows.ReadDirectoryChanges(
                watch.handle,
                &watch.buffer[0],
                uint32(len(watch.buffer)),
                wfm.config.Recursive,
                windows.FILE_NOTIFY_CHANGE_FILE_NAME|
                windows.FILE_NOTIFY_CHANGE_DIR_NAME|
                windows.FILE_NOTIFY_CHANGE_SIZE|
                windows.FILE_NOTIFY_CHANGE_LAST_WRITE,
                &bytesReturned,
                watch.overlapped,
                0,
            )
            
            if err != nil {
                wfm.logger.Error("ReadDirectoryChanges failed: %v", err)
                time.Sleep(1 * time.Second)
                continue
            }
            
            wfm.parseNotifications(watch.buffer[:bytesReturned], watch.path)
        }
    }
}

func (wfm *WindowsFileMonitor) parseNotifications(buffer []byte, basePath string) {
    offset := 0
    
    for offset < len(buffer) {
        // Parse FILE_NOTIFY_INFORMATION structure
        nextEntryOffset := *(*uint32)(unsafe.Pointer(&buffer[offset]))
        action := *(*uint32)(unsafe.Pointer(&buffer[offset+4]))
        fileNameLength := *(*uint32)(unsafe.Pointer(&buffer[offset+8]))
        
        // Extract filename (UTF-16)
        filenameBytes := buffer[offset+12 : offset+12+int(fileNameLength)]
        filename := windows.UTF16ToString((*(*[]uint16)(unsafe.Pointer(&filenameBytes)))[:fileNameLength/2])
        
        fullPath := filepath.Join(basePath, filename)
        
        // Create file event
        event := &FileEvent{
            AgentID:   wfm.agent.Config.Agent.ID,
            Timestamp: time.Now(),
            EventType: "file",
            FilePath:  fullPath,
            FileName:  filename,
            Action:    wfm.actionToString(action),
            Platform:  "windows",
        }
        
        // Get file info
        if stat, err := os.Stat(fullPath); err == nil {
            event.FileSize = stat.Size()
        }
        
        // Calculate hash if needed
        if wfm.shouldCalculateHash(event) {
            event.Hash = wfm.calculateFileHash(fullPath)
        }
        
        // YARA scan if enabled
        if wfm.config.ScanOnWrite && event.Action == "created" {
            go wfm.scanFile(fullPath)
        }
        
        // Send event to agent
        wfm.agent.RegisterEvent(event)
        
        if nextEntryOffset == 0 {
            break
        }
        offset += int(nextEntryOffset)
    }
}

// Implementation continues for Process Monitor, Registry Monitor, etc.
```

#### **B. Windows Service**
```go
// internal/windows/service.go
package windows

import (
    "golang.org/x/sys/windows/svc"
    "golang.org/x/sys/windows/svc/debug"
    "golang.org/x/sys/windows/svc/eventlog"
)

type WindowsEDRService struct {
    agent *common.Agent
    elog  debug.Log
}

func (w *WindowsEDRService) Execute(args []string, r <-chan svc.ChangeRequest, changes chan<- svc.Status) (ssec bool, errno uint32) {
    const cmdsAccepted = svc.AcceptStop | svc.AcceptShutdown
    changes <- svc.Status{State: svc.StartPending}
    
    // Start EDR Agent
    err := w.agent.Start()
    if err != nil {
        w.elog.Error(1, fmt.Sprintf("Failed to start agent: %v", err))
        return true, 1
    }
    
    changes <- svc.Status{State: svc.Running, Accepts: cmdsAccepted}
    w.elog.Info(1, "EDR Agent service started")
    
    for {
        select {
        case c := <-r:
            switch c.Cmd {
            case svc.Interrogate:
                changes <- c.CurrentStatus
            case svc.Stop, svc.Shutdown:
                w.elog.Info(1, "EDR Agent service stopping")
                w.agent.Stop()
                changes <- svc.Status{State: svc.StopPending}
                return
            default:
                w.elog.Error(1, fmt.Sprintf("Unexpected control request #%d", c))
            }
        }
    }
}

func RunWindowsService() error {
    elog, err := eventlog.Open("EDR-Agent")
    if err != nil {
        return err
    }
    defer elog.Close()
    
    agent, err := common.NewAgent("windows")
    if err != nil {
        return err
    }
    
    service := &WindowsEDRService{
        agent: agent,
        elog:  elog,
    }
    
    return svc.Run("EDR-Agent", service)
}
```

### **3. 🐧 Linux-Specific Implementation**

#### **A. File Monitoring (inotify)**
```go
// internal/linux/file_monitor.go
package linux

import (
    "golang.org/x/sys/unix"
    "path/filepath"
)

type LinuxFileMonitor struct {
    config     common.FileMonitorConfig
    logger     *common.Logger
    agent      *common.Agent
    inotifyFd  int
    watchMap   map[int]string
    stopChan   chan bool
}

func NewLinuxFileMonitor(config common.FileMonitorConfig, logger *common.Logger, agent *common.Agent) *LinuxFileMonitor {
    return &LinuxFileMonitor{
        config:   config,
        logger:   logger,
        agent:    agent,
        watchMap: make(map[int]string),
        stopChan: make(chan bool),
    }
}

func (lfm *LinuxFileMonitor) Start() error {
    lfm.logger.Info("Starting Linux file monitor...")
    
    // Create inotify instance
    fd, err := unix.InotifyInit1(unix.IN_CLOEXEC)
    if err != nil {
        return err
    }
    lfm.inotifyFd = fd
    
    // Add watches for all paths
    for _, path := range lfm.config.Paths {
        err := lfm.addRecursiveWatch(path)
        if err != nil {
            lfm.logger.Error("Failed to watch directory %s: %v", path, err)
            continue
        }
        lfm.logger.Info("Watching directory: %s", path)
    }
    
    // Start monitoring
    go lfm.monitorEvents()
    
    return nil
}

func (lfm *LinuxFileMonitor) Stop() {
    lfm.logger.Info("Stopping Linux file monitor...")
    close(lfm.stopChan)
    unix.Close(lfm.inotifyFd)
}

func (lfm *LinuxFileMonitor) addRecursiveWatch(path string) error {
    return filepath.Walk(path, func(walkPath string, info os.FileInfo, err error) error {
        if err != nil {
            return nil
        }
        
        if info.IsDir() {
            wd, err := unix.InotifyAddWatch(
                lfm.inotifyFd,
                walkPath,
                unix.IN_CREATE|unix.IN_DELETE|unix.IN_MODIFY|
                unix.IN_MOVED_FROM|unix.IN_MOVED_TO|unix.IN_ATTRIB,
            )
            if err != nil {
                return nil
            }
            
            lfm.watchMap[wd] = walkPath
        }
        
        return nil
    })
}

func (lfm *LinuxFileMonitor) monitorEvents() {
    buffer := make([]byte, 4096)
    
    for {
        select {
        case <-lfm.stopChan:
            return
        default:
            n, err := unix.Read(lfm.inotifyFd, buffer)
            if err != nil {
                lfm.logger.Error("inotify read failed: %v", err)
                continue
            }
            
            lfm.parseInotifyEvents(buffer[:n])
        }
    }
}

// Implementation continues...
```

### **4. 📋 Tasks cần implement**

#### **A. Priority 1 - Core Functions:**
1. **Agent Registration** - Đăng ký với server
2. **Heartbeat** - Báo trạng thái định kỳ  
3. **File Monitoring** - Monitor file system changes
4. **Event Sending** - Gửi events về server
5. **YARA Scanning** - Scan files với YARA rules
6. **Service/Daemon** - Chạy như system service

#### **B